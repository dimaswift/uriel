using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Globalization; 
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using Uriel.Behaviours;
using Uriel.Domain;
using Uriel.Utils;

[Serializable]
public class LaserSettings
{
    [Header("Engraving Area")]
    [Tooltip("Width of engraving area in millimeters")]
    public float areaWidth = 300f;
    [Tooltip("Height of engraving area in millimeters")]
    public float areaHeight = 200f;
    [Tooltip("Position of the engraving area origin (0,0) in Unity world space")]
    public Vector3 originPosition = Vector3.zero;
    [Tooltip("Color for drawing the engraving area in the editor")]
    public Color areaColor = new Color(0.2f, 0.8f, 0.2f, 0.5f);
    [Tooltip("Show the engraving area grid")]
    public bool showGrid = true;
    [Tooltip("Grid cell size in millimeters")]
    public float gridSize = 10f;
}

public class GCodeGenerator : MonoBehaviour
{
    [SerializeField] private LaserSettings laserSettings = new LaserSettings();
    [SerializeField] private Transform targetObject; // Object to track for movement
    [SerializeField] private bool generateGCodeOnMovement = true;
    [SerializeField] private string outputFilePath = "Assets/GCode/output.gcode";
    [SerializeField] private bool appendToFile = false;
    [SerializeField] private bool clampToEngravingArea = true;
    [SerializeField] private MeshRenderer preview;
    [SerializeField] private ComputeShader fieldShader;
    [SerializeField] private Engraving config;
    private Vector3 lastPosition;
    private StringBuilder gCodeBuffer = new StringBuilder();
    private int currentSValue = 0;
    private bool isInitialized = false;

    // Events
    public delegate void GCodeGeneratedHandler(string gcode);
    public event GCodeGeneratedHandler OnGCodeGenerated;

    private RenderTexture previewTexture;
    private PhotonBuffer photonBuffer;

    private void Start()
    {
        if (targetObject == null)
            targetObject = transform;
            
        lastPosition = targetObject.position;
        isInitialized = true;
        
        // Initialize with a header
        AppendGCode("; G-code generated by Unity Laser Engraver Emulator");
        AppendGCode("; Date: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture));
        AppendGCode("; Engraving area: " + 
                    string.Format(CultureInfo.InvariantCulture, "{0}mm x {1}mm", 
                    laserSettings.areaWidth, laserSettings.areaHeight));
        AppendGCode("G90"); // Set absolute positioning
        AppendGCode("G21"); // Set units to millimeters
        
        // Initialize laser in off state
        AppendGCode("M4 S0");
        currentSValue = 0;

        photonBuffer = gameObject.GetComponent<PhotonBuffer>().LinkComputeKernel(fieldShader);
        
        GeneratePreviewTexture();
    }

    private void GeneratePreviewTexture()
    {
        if (previewTexture != null) previewTexture.Release();
        var w = Mathf.RoundToInt(config.width / config.precision);
        var h = Mathf.RoundToInt(config.height / config.precision);
        previewTexture = new RenderTexture(w, h, 0, GraphicsFormat.R32G32B32A32_SFloat)
        {
            enableRandomWrite = true,
            useMipMap = false,
            autoGenerateMips = false,
            filterMode = FilterMode.Point
        };
        previewTexture.Create();
        preview.material.mainTexture = previewTexture;
        preview.transform.parent.localScale = new Vector3(config.height, 1, config.width);

        fieldShader.SetTexture(0, ShaderProps.Texture, previewTexture);
        fieldShader.SetInt(ShaderProps.Width, w);
        fieldShader.SetInt(ShaderProps.Height, h);
        
        print($"Width: {w}, Height: {h}");

    }

    void GenerateCodeFromTexture()
    {
        // Setup and read texture data
        RenderTexture tempRT = RenderTexture.GetTemporary(previewTexture.width, previewTexture.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(previewTexture, tempRT);
        Texture2D tex2D = new Texture2D(tempRT.width, tempRT.height, TextureFormat.RGBA32, false);
        RenderTexture.active = tempRT;
        tex2D.ReadPixels(new Rect(0, 0, tempRT.width, tempRT.height), 0, 0);
        tex2D.Apply();
        RenderTexture.active = null;
        RenderTexture.ReleaseTemporary(tempRT);
        
        // G-code initialization
        AppendGCode("; Vertical scan G-code generation");
        AppendGCode(string.Format(CultureInfo.InvariantCulture, "; Dimensions: {0}x{1}", previewTexture.width, previewTexture.height));
        AppendGCode("G90"); // Absolute positioning
        AppendGCode("G21"); // Millimeters
        
        // Initial state
        AppendGCode("M4"); // Variable power mode
        int currentLaserPower = 0;
        float currentFeedRate = 0;
        
        // Scan vertically with serpentine pattern (alternate up/down direction)
        for (int x = 0; x < previewTexture.width; x++)
        {
            // Determine direction based on column number
            bool bottomToTop = (x % 2 == 0);
            
            // Move to the starting position of this column with laser at minimum power
            int startY = bottomToTop ? 0 : previewTexture.height - 1;
            Vector3 startPos = WorldToLaserCoordinates(new Vector3(x, 0, startY) * config.precision);
            
            // Set minimum power for travel move
            AppendGCode(string.Format(CultureInfo.InvariantCulture, "S{0}", config.minPower));
            AppendGCode(string.Format(CultureInfo.InvariantCulture, "G0 X{0:F3} Y{1:F3}", startPos.x, startPos.y));
            
            // Process the column
            for (int yIndex = 0; yIndex < previewTexture.height; yIndex++)
            {
                // Calculate actual y position based on direction
                int y = bottomToTop ? yIndex : previewTexture.height - 1 - yIndex;
                
                // Get pixel and position
                var pixel = tex2D.GetPixel(x, y);
                Vector3 laserPos = WorldToLaserCoordinates(new Vector3(x, 0, y) * config.precision);
                
                // Use G value for both power and speed modulation
                float gValue = 1.0f - Math.Max(0.0f, pixel.g); // Ensure minimum value of 0.1
                
                // Calculate power based on G value
                int laserPower = Mathf.RoundToInt(MathUtils.Map(gValue, 0.0f, 1f, config.minPower, config.maxPower));
                
                // Calculate feed rate based on G value (inverted: darker = slower)
                float feedRate = MathUtils.Map(gValue, 1.0f, 0f, config.minFeedRate, config.maxFeedRate);
                
                // Only output power command if power has changed
                if (laserPower != currentLaserPower)
                {
                    AppendGCode(string.Format(CultureInfo.InvariantCulture, "S{0}", laserPower));
                    currentLaserPower = laserPower;
                }
                
                // Only output feed rate if it has changed
                if (Math.Abs(feedRate - currentFeedRate) > 10)
                {
                    currentFeedRate = feedRate;
                }
                
                // Output the movement command with current feed rate
                AppendGCode(string.Format(CultureInfo.InvariantCulture, 
                    "G1 X{0:F3} Y{1:F3} F{2:F0}", laserPos.x, laserPos.y, currentFeedRate));
            }
        }
        
        // End G-code - turn off laser and reset
        AppendGCode("S0");
        AppendGCode("M5");
        
        // Memory cleanup
        Destroy(tex2D);
    }

    private void FillPreviewTexture()
    {
        fieldShader.SetFloat(ShaderProps.Scale,config.scale);
        fieldShader.SetVector(ShaderProps.Offset, targetObject.position);
        fieldShader.SetVector(ShaderProps.Steps, new Vector4(config.steps.x, config.steps.y, config.steps.z, 0));
        fieldShader.SetFloat("_SpeedThreshold", config.speedThreshold);
        fieldShader.SetFloat("_SpeedMultiplier", config.speedMultiplier);
        fieldShader.SetFloat("_PowerThreshold", config.powerThreshold);
        fieldShader.SetFloat("_PowerMultiplier", config.powerMultiplier);
        
        fieldShader.Dispatch(0, Mathf.CeilToInt(previewTexture.width / 8f), Mathf.CeilToInt(previewTexture.height / 8f), 1);
    }
    
    private void OnDestroy()
    {
        if (previewTexture) previewTexture.Release();
    }

    private void Update()
    {
        if (!isInitialized || !generateGCodeOnMovement || targetObject == null)
            return;
            
        // Check if the object has moved enough to generate a new G-code command
        if (Vector3.Distance(lastPosition, targetObject.position) >= config.precision)
        {
            GenerateMovementGCode(targetObject.position);
            lastPosition = targetObject.position;
        }

        if (Input.GetKeyDown(KeyCode.Space))
        {
            SetLaserPower(25);
        }

        if (Input.GetKeyDown(KeyCode.S))
        {
            
            GenerateCodeFromTexture();
            
            SaveGCodeToFile();
        }

        if (Input.GetKeyDown(KeyCode.D))
        {
            StartCoroutine(GenerateDepthGCode());
        }

        FillPreviewTexture();
    }

    private IEnumerator GenerateDepthGCode()
    {
        for (float i = config.zStart; i < config.zEnd; i+=config.zStep)
        {
            Photon w = photonBuffer.Lumen.photons[0];
            Matrix4x4 s = w.transform;
            s[0,3] = i;
            w.transform = s;
            photonBuffer.Lumen.photons[0] = w;
            GenerateCodeFromTexture();
            yield return new WaitForSeconds(0.1f);
        }
        SaveGCodeToFile();
    }
    
    // Convert Unity world position to laser engraver coordinates
    public Vector3 WorldToLaserCoordinates(Vector3 worldPosition)
    {
        // Calculate position relative to the origin
        Vector3 relativePos = worldPosition - laserSettings.originPosition;
        
        // Convert to laser coordinate system (Unity's Y is CNC's Z, Unity's Z is CNC's Y)
        float x = relativePos.x;
        float y = relativePos.z; // Forward in Unity = Y in CNC
        float z = relativePos.y; // Up in Unity = Z in CNC
        
        // Clamp to engraving area if required
        if (clampToEngravingArea)
        {
            x = Mathf.Clamp(x, 0, laserSettings.areaWidth);
            y = Mathf.Clamp(y, 0, laserSettings.areaHeight);
        }
        
        return new Vector3(x, y, z);
    }
    
    // Convert laser engraver coordinates to Unity world position
    public Vector3 LaserToWorldCoordinates(Vector3 laserPosition)
    {
        // Convert from laser coordinates to Unity coordinates
        float x = laserPosition.x;
        float y = laserPosition.z; // Z in CNC = Y in Unity
        float z = laserPosition.y; // Y in CNC = Z in Unity
        
        // Apply the origin offset
        Vector3 worldPos = new Vector3(x, y, z) + laserSettings.originPosition;
        
        return worldPos;
    }
    
    // Generate G-code for movement to a position
    public void GenerateMovementGCode(Vector3 worldPosition)
    {
        // Convert from world position to laser coordinates
        Vector3 laserPos = WorldToLaserCoordinates(worldPosition);
        
        string command = currentSValue > 0 ? "G1" : "G0";
        string gcode = string.Format(CultureInfo.InvariantCulture, 
            "{0} X{1:F3} Y{2:F3}", command, laserPos.x, laserPos.y);
            
        // Add Z coordinate only if it's non-zero (many laser engravers don't use Z)
        if (Mathf.Abs(laserPos.z) > 0.001f)
        {
            gcode += string.Format(CultureInfo.InvariantCulture, " Z{0:F3}", laserPos.z);
        }
        
        // Add feed rate for controlled movements
        if (currentSValue > 0)
            gcode += string.Format(CultureInfo.InvariantCulture, " F{0}", config.minFeedRate);
            
        AppendGCode(gcode);
    }
    
    // Generate G-code for arc movement (G2/G3)
    public void GenerateArcGCode(bool clockwise, Vector3 endWorldPos, Vector3 centerOffset, float feedRate = 0)
    {
        // Convert to laser coordinates
        Vector3 endPos = WorldToLaserCoordinates(endWorldPos);
        
        // In G-code, I and J are relative offsets from the start point to the center
        string command = clockwise ? "G2" : "G3";
        
        string gcode = string.Format(CultureInfo.InvariantCulture,
            "{0} X{1:F3} Y{2:F3}", command, endPos.x, endPos.y);
            
        // Add Z if needed
        if (Mathf.Abs(endPos.z) > 0.001f)
        {
            gcode += string.Format(CultureInfo.InvariantCulture, " Z{0:F3}", endPos.z);
        }
        
        // Add center offsets
        gcode += string.Format(CultureInfo.InvariantCulture, " I{0:F3} J{1:F3}", centerOffset.x, centerOffset.y);
        
        // Add feed rate if specified
        if (feedRate > 0)
        {
            gcode += string.Format(CultureInfo.InvariantCulture, " F{0}", feedRate);
        }
        else if (currentSValue > 0 && config.minFeedRate > 0)
        {
            gcode += string.Format(CultureInfo.InvariantCulture, " F{0}", config.minFeedRate);
        }
        
        AppendGCode(gcode);
    }
    
    // Set the laser power (0-100%)
    public void SetLaserPower(float powerPercent)
    {
        // laserSettings.power = Mathf.Clamp(powerPercent, 0f, 100f);
        // int sValue = ScalePowerToGCode(laserSettings.power);
        //
        // // If the laser wasn't active and now has power
        // if (sValue > 0 && !laserActive)
        // {
        //     // Turn laser on in dynamic power mode (M4)
        //     AppendGCode(string.Format(CultureInfo.InvariantCulture, "M4 S{0}", sValue));
        //     laserActive = true;
        //     currentSValue = sValue;
        // }
        // // If the laser was active and now has no power
        // else if (sValue <= 0 && laserActive)
        // {
        //     // First set S0
        //     AppendGCode("S0");
        //     // Then formally turn laser off with M5
        //     AppendGCode("M5");
        //     laserActive = false;
        //     currentSValue = 0;
        // }
        // // If just changing power
        // else if (sValue != currentSValue)
        // {
        //     // Just send updated S value as a separate command
        //     AppendGCode(string.Format(CultureInfo.InvariantCulture, "S{0}", sValue));
        //     currentSValue = sValue;
        // }
    }
    

    // Add a custom G-code command
    public void AppendGCode(string gcode)
    {
        gCodeBuffer.AppendLine(gcode);
        OnGCodeGenerated?.Invoke(gcode);
    }
    
    // Save the current G-code buffer to a file
    public void SaveGCodeToFile()
    {
        try
        {
            if (appendToFile && File.Exists(outputFilePath))
            {
                File.AppendAllText(outputFilePath, gCodeBuffer.ToString());
            }
            else
            {
                Directory.CreateDirectory(Path.GetDirectoryName(outputFilePath));
                File.WriteAllText(outputFilePath, gCodeBuffer.ToString());
            }
            
            Debug.Log($"G-code saved to {outputFilePath}");
            gCodeBuffer.Clear();
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to save G-code: {e.Message}");
        }
    }
    
    // Clear the current G-code buffer
    public void ClearGCodeBuffer()
    {
        gCodeBuffer.Clear();
    }
    
    // G-code Parser
    public class GCodeParser
    {
        public class GCodeCommand
        {
            public string CommandType { get; set; }
            public Dictionary<char, float> Parameters { get; set; } = new Dictionary<char, float>();
            public string RawCommand { get; set; }
            
            public bool HasParameter(char key)
            {
                return Parameters.ContainsKey(key);
            }
            
            public float GetParameter(char key, float defaultValue = 0f)
            {
                return Parameters.TryGetValue(key, out float value) ? value : defaultValue;
            }
        }
        
        public static GCodeCommand ParseLine(string line)
        {
            // Remove comments
            int commentIndex = line.IndexOf(';');
            if (commentIndex >= 0)
                line = line.Substring(0, commentIndex).Trim();
                
            if (string.IsNullOrWhiteSpace(line))
                return null;
                
            GCodeCommand command = new GCodeCommand { RawCommand = line };
            
            // Extract the command type (G1, M3, S value, etc.)
            string[] parts = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length > 0)
            {
                // Handle standalone S commands (S1000, S0)
                if (parts[0].StartsWith("S", StringComparison.OrdinalIgnoreCase))
                {
                    command.CommandType = "S";
                    if (float.TryParse(parts[0].Substring(1), 
                                      NumberStyles.Float, 
                                      CultureInfo.InvariantCulture, 
                                      out float value))
                    {
                        command.Parameters['S'] = value;
                    }
                }
                else
                {
                    command.CommandType = parts[0];
                }
                
                // Parse parameters (start from index 0 for standalone S commands)
                int startIndex = command.CommandType == "S" ? 1 : 0;
                for (int i = startIndex; i < parts.Length; i++)
                {
                    if (parts[i].Length >= 2 && char.IsLetter(parts[i][0]))
                    {
                        char key = parts[i][0];
                        if (float.TryParse(parts[i].Substring(1), 
                                          NumberStyles.Float, 
                                          CultureInfo.InvariantCulture, 
                                          out float value))
                        {
                            command.Parameters[key] = value;
                        }
                    }
                }
            }
            
            return command;
        }
    }
    
    // Helper to calculate arc center from radius
    private Vector2 CalculateArcCenter(Vector2 startPoint, Vector2 endPoint, float radius, bool clockwise)
    {
        // Calculate midpoint
        Vector2 midPoint = (startPoint + endPoint) * 0.5f;
        
        // Calculate distance between points
        float distance = Vector2.Distance(startPoint, endPoint);
        
        // Check if arc is possible
        if (distance > 2 * radius)
        {
            Debug.LogWarning("Arc radius too small for the points");
            return midPoint;
        }
        
        // Direction vector from start to end
        Vector2 direction = endPoint - startPoint;
        
        // Normalized perpendicular
        Vector2 perpendicular = new Vector2(-direction.y, direction.x).normalized;
        
        // Distance from midpoint to center
        float distToCenter = Mathf.Sqrt(radius * radius - (distance * distance / 4));
        
        // Adjust direction based on clockwise flag
        if (clockwise)
            perpendicular = -perpendicular;
            
        // Calculate center
        return midPoint + perpendicular * distToCenter;
    }
    
    // Execute a G-code command
    public bool ExecuteGCodeCommand(string commandLine)
    {
        // GCodeParser.GCodeCommand cmd = GCodeParser.ParseLine(commandLine);
        // if (cmd == null)
        //     return false;
        //     
        // try
        // {
        //     switch (cmd.CommandType)
        //     {
        //         case "G0":
        //         case "G1":
        //             // Movement command - Parse coordinates in laser space
        //             float x = cmd.GetParameter('X', float.NaN);
        //             float y = cmd.GetParameter('Y', float.NaN);
        //             float z = cmd.GetParameter('Z', float.NaN);
        //             
        //             // Create laser coordinates vector using current position for any unspecified values
        //             Vector3 currentLaserPos = WorldToLaserCoordinates(targetObject.position);
        //             Vector3 laserPos = new Vector3(
        //                 float.IsNaN(x) ? currentLaserPos.x : x,
        //                 float.IsNaN(y) ? currentLaserPos.y : y,
        //                 float.IsNaN(z) ? currentLaserPos.z : z
        //             );
        //             
        //             // Convert to Unity world coordinates
        //             Vector3 worldPos = LaserToWorldCoordinates(laserPos);
        //             
        //             // Update the object position
        //             targetObject.position = worldPos;
        //             
        //             // Update feed rate if specified
        //             if (cmd.HasParameter('F'))
        //             {
        //                 config.speed = (int)cmd.GetParameter('F');
        //             }
        //             break;
        //             
        //         case "G2": // Clockwise arc
        //         case "G3": // Counter-clockwise arc
        //             bool isClockwise = cmd.CommandType == "G2";
        //             
        //             // Get current position in laser coordinates
        //             Vector3 currentLaserPosition = WorldToLaserCoordinates(targetObject.position);
        //             
        //             // Get target position
        //             float arcX = cmd.GetParameter('X', currentLaserPosition.x);
        //             float arcY = cmd.GetParameter('Y', currentLaserPosition.y);
        //             float arcZ = cmd.GetParameter('Z', currentLaserPosition.z);
        //             
        //             // Get center offset (I and J are offsets from start position to center)
        //             float i = cmd.GetParameter('I', 0);
        //             float j = cmd.GetParameter('J', 0);
        //             
        //             // Calculate arc center
        //             Vector2 startPoint = new Vector2(currentLaserPosition.x, currentLaserPosition.y);
        //             Vector2 centerPoint = startPoint + new Vector2(i, j);
        //             Vector2 endPoint = new Vector2(arcX, arcY);
        //             
        //             // For visualization in Unity, we could draw the arc
        //             // But for now, we'll just move to the endpoint
        //             Vector3 arcEndPos = LaserToWorldCoordinates(new Vector3(arcX, arcY, arcZ));
        //             targetObject.position = arcEndPos;
        //             
        //             // Update feed rate if specified
        //             if (cmd.HasParameter('F'))
        //             {
        //                 laserSettings.feedRate = cmd.GetParameter('F');
        //             }
        //             break;
        //             
        //         case "M3": // Constant laser power
        //         case "M4": // Dynamic laser power
        //             // Get S value (laser power)
        //             if (cmd.HasParameter('S'))
        //             {
        //                 int sValue = Mathf.RoundToInt(cmd.GetParameter('S'));
        //                 currentSValue = sValue;
        //                 laserSettings.power = GCodeToScaledPower(sValue);
        //                 laserActive = sValue > 0;
        //             }
        //             else
        //             {
        //                 laserActive = true;
        //             }
        //             break;
        //             
        //         case "M5": // Laser off
        //             laserSettings.power = 0f;
        //             currentSValue = 0;
        //             laserActive = false;
        //             break;
        //             
        //         case "S":  // Standalone S command to adjust power
        //             if (cmd.HasParameter('S'))
        //             {
        //                 int sValue = Mathf.RoundToInt(cmd.GetParameter('S'));
        //                 currentSValue = sValue;
        //                 laserSettings.power = GCodeToScaledPower(sValue);
        //                 // Change active state based on power
        //                 laserActive = sValue > 0;
        //             }
        //             break;
        //             
        //         case "G90":
        //             // Absolute positioning - this is our default in Unity
        //             break;
        //             
        //         case "G91":
        //             Debug.LogWarning("Relative positioning (G91) is not fully supported");
        //             break;
        //             
        //         default:
        //             Debug.LogWarning($"Unsupported G-code command: {cmd.CommandType}");
        //             return false;
        //     }
        //     
        //     return true;
        // }
        // catch (Exception e)
        // {
        //     Debug.LogError($"Error executing G-code command: {e.Message}");
        //     return false;
        // }
        return false;
    }
    
    // Execute a complete G-code file
    public void ExecuteGCodeFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            Debug.LogError($"G-code file not found: {filePath}");
            return;
        }
        
        string[] lines = File.ReadAllLines(filePath);
        foreach (string line in lines)
        {
            ExecuteGCodeCommand(line);
        }
    }
    
    // Stream G-code to a connected device (placeholder for actual implementation)
    public void StreamGCodeToDevice(string portName, int baudRate = 115200)
    {
        Debug.Log($"Would stream G-code to {portName} at {baudRate} baud");
        // Implementation would depend on your specific hardware interface
        // Using System.IO.Ports.SerialPort for actual implementation
    }
    
    // Draw gizmos to visualize the engraving area
    private void OnDrawGizmos()
    {
        // Draw the engraving area
        DrawEngravingArea();
    }
    
    private void DrawEngravingArea()
    {
        // Save the original Gizmos color
        Color originalColor = Gizmos.color;
        
        // Set the color for the engraving area
        Gizmos.color = laserSettings.areaColor;
        
        // Define the corners of the area in laser space
        Vector3 bottomLeft = new Vector3(0, 0, 0);
        Vector3 bottomRight = new Vector3(laserSettings.areaWidth, 0, 0);
        Vector3 topLeft = new Vector3(0, laserSettings.areaHeight, 0);
        Vector3 topRight = new Vector3(laserSettings.areaWidth, laserSettings.areaHeight, 0);
        
        // Convert to world space
        Vector3 worldBottomLeft = LaserToWorldCoordinates(bottomLeft);
        Vector3 worldBottomRight = LaserToWorldCoordinates(bottomRight);
        Vector3 worldTopLeft = LaserToWorldCoordinates(topLeft);
        Vector3 worldTopRight = LaserToWorldCoordinates(topRight);
        
        // Draw the area outline
        Gizmos.DrawLine(worldBottomLeft, worldBottomRight);
        Gizmos.DrawLine(worldBottomRight, worldTopRight);
        Gizmos.DrawLine(worldTopRight, worldTopLeft);
        Gizmos.DrawLine(worldTopLeft, worldBottomLeft);
        
        // Draw a plane to represent the engraving area
        Vector3 center = LaserToWorldCoordinates(new Vector3(
            laserSettings.areaWidth / 2, 
            laserSettings.areaHeight / 2, 
            0));
        Vector3 size = new Vector3(laserSettings.areaWidth, 0.01f, laserSettings.areaHeight);
        
        // Adjust for the Unity coordinate system
        Quaternion rotation = Quaternion.Euler(90, 0, 0);
        Matrix4x4 matrix = Matrix4x4.TRS(center, rotation, Vector3.one);
        
    
        
        // Reset matrix
        Gizmos.matrix = Matrix4x4.identity;
        
        // Draw the grid if enabled
        if (laserSettings.showGrid && laserSettings.gridSize > 0)
        {
            Gizmos.color = new Color(laserSettings.areaColor.r, laserSettings.areaColor.g, laserSettings.areaColor.b, 0.3f);
            
            // Draw vertical grid lines
            for (float x = 0; x <= laserSettings.areaWidth; x += laserSettings.gridSize)
            {
                Vector3 bottom = LaserToWorldCoordinates(new Vector3(x, 0, 0));
                Vector3 top = LaserToWorldCoordinates(new Vector3(x, laserSettings.areaHeight, 0));
                Gizmos.DrawLine(bottom, top);
            }
            
            // Draw horizontal grid lines
            for (float y = 0; y <= laserSettings.areaHeight; y += laserSettings.gridSize)
            {
                Vector3 left = LaserToWorldCoordinates(new Vector3(0, y, 0));
                Vector3 right = LaserToWorldCoordinates(new Vector3(laserSettings.areaWidth, y, 0));
                Gizmos.DrawLine(left, right);
            }
        }
        
        // Draw the origin point
        Gizmos.color = Color.red;
        Gizmos.DrawSphere(laserSettings.originPosition, 0.1f);
        
        // Draw X axis
        Gizmos.color = Color.red;
        Gizmos.DrawLine(laserSettings.originPosition, 
                        laserSettings.originPosition + Vector3.right * Mathf.Min(1.0f, laserSettings.areaWidth * 0.1f));
        
        // Draw Y axis (Z in Unity)
        Gizmos.color = Color.blue;
        Gizmos.DrawLine(laserSettings.originPosition, 
                        laserSettings.originPosition + Vector3.forward * Mathf.Min(1.0f, laserSettings.areaHeight * 0.1f));
        
        // Draw Z axis (Y in Unity)
        Gizmos.color = Color.green;
        Gizmos.DrawLine(laserSettings.originPosition, 
                        laserSettings.originPosition + Vector3.up * 1.0f);
        
        // Restore the original Gizmos color
        Gizmos.color = originalColor;
    }
    
    // Draw an arc in scene view for debug visualization
    private void DrawArc(Vector3 startPos, Vector3 endPos, Vector3 center, bool clockwise, int segments = 32)
    {
        // Convert all to world space
        Vector3 worldStart = LaserToWorldCoordinates(startPos);
        Vector3 worldEnd = LaserToWorldCoordinates(endPos);
        Vector3 worldCenter = LaserToWorldCoordinates(center);
        
        // Calculate radius
        float radius = Vector3.Distance(worldStart, worldCenter);
        
        // Calculate start and end angles
        Vector3 startDir = worldStart - worldCenter;
        Vector3 endDir = worldEnd - worldCenter;
        
        float startAngle = Mathf.Atan2(startDir.z, startDir.x) * Mathf.Rad2Deg;
        float endAngle = Mathf.Atan2(endDir.z, endDir.x) * Mathf.Rad2Deg;
        
        // Ensure positive angles
        if (startAngle < 0) startAngle += 360;
        if (endAngle < 0) endAngle += 360;
        
        // Adjust for clockwise/counterclockwise
        float sweepAngle;
        if (clockwise)
        {
            if (endAngle > startAngle) endAngle -= 360;
            sweepAngle = endAngle - startAngle;
        }
        else
        {
            if (startAngle > endAngle) endAngle += 360;
            sweepAngle = endAngle - startAngle;
        }
        
        // Draw the arc
        float angleStep = sweepAngle / segments;
        Vector3 prevPoint = worldStart;
        
        for (int i = 1; i <= segments; i++)
        {
            float angle = startAngle + angleStep * i;
            float x = worldCenter.x + radius * Mathf.Cos(angle * Mathf.Deg2Rad);
            float z = worldCenter.z + radius * Mathf.Sin(angle * Mathf.Deg2Rad);
            Vector3 newPoint = new Vector3(x, worldCenter.y, z);
            
            Gizmos.DrawLine(prevPoint, newPoint);
            prevPoint = newPoint;
        }
    }
}

