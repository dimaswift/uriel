#pragma kernel Init
#pragma kernel Process

#include "Assets/Scripts/Lib/Uriel.cginc"

#define SAMPLE_STEPS 2

RWStructuredBuffer<float4x4> _Particles;
int _ParticlesCount;
uint _WaveCount;
float _Size;
StructuredBuffer<Wave> _WaveBuffer;
uint _SolidType;
float _Scale;
float3 _Offset;
float4x4 _Reference;
float _SampleRadius;
float _DeltaTime;
float _Speed;

[numthreads(64, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    float4x4 p = _Particles[id.x];
    _Particles[id.x] = p;
}

[numthreads(64, 1, 1)]
void Process(uint3 id : SV_DispatchThreadID)
{
    float s = _Size;
    float4x4 p = _Particles[id.x];
    float3 pos = float3(p[0][3], p[1][3], p[2][3]);
    
    float density = 0.0;
    const float phase = p[3][1];
    const float3 sample_point = ((pos) * _Scale);
    float3 gradient = float3(0,0,0);
    uint size;
    const Wave wave = _WaveBuffer[0];
    switch (wave.type)
    {
        case Solid::Tetrahedron:
            size = TETRAHEDRON_SIZE;
            break;
        case Solid::Octahedron:
            size = OCTAHEDRON_SIZE;
            break;
        case Solid::Cube:
            size = CUBE_SIZE;
            break;
        case Solid::Icosahedron:
            size = ICOSAHEDRON_SIZE;
            break;
        case Solid::Dodecahedron:
            size = DODECAHEDRON_SIZE;
            break;
        default:
            size = 0;
            break;
    }
    for (uint i = 0; i < size; i++)
    {
        float3 vertex;
        switch (wave.type)
        {
        case Solid::Tetrahedron:
            vertex = TETRAHEDRON[i];
            break;
        case Solid::Octahedron:
            vertex = OCTAHEDRON[i];
            break;
        case Solid::Cube:
            vertex = CUBE[i];
            break;
        case Solid::Icosahedron:
            vertex = ICOSAHEDRON[i];
            break;
        case Solid::Dodecahedron:
            vertex = DODECAHEDRON[i];
            break;
        default:
            vertex = float3(0,0,0);
            break;
        }
 
        const float sample_offset = float(SAMPLE_STEPS) * 0.5;
       
        
        for (int x = 0; x < SAMPLE_STEPS; x++)
        {
            for (int y = 0; y < SAMPLE_STEPS; y++)
            {
                for (int z = 0; z < SAMPLE_STEPS; z++)
                {
                    const float3 offset = float3(x - sample_offset, y - sample_offset, z - sample_offset) * _SampleRadius;
                    const float dist = saturate(distance(sample_point + offset, vertex) * wave.density);
                    const float d = sin(dist * wave.frequency) * wave.amplitude;
                    gradient += offset * d;
                    density += d;
                }
            }
        }
    }
    
    const float4x4 translationMatrix = float4x4(  
        s, 0, 0, pos.x + gradient.x * _Speed * _DeltaTime,  
        0, s, 0, pos.y + gradient.y * _Speed * _DeltaTime,  
        0, 0, s, pos.z + gradient.z * _Speed * _DeltaTime,  
        0, 0, 0, 1  
    );  
    
    float4x4 final = translationMatrix;
    final[3][0] = density;
    _Particles[id.x] = final;
}

