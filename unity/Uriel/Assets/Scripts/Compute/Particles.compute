#pragma kernel Init
#pragma kernel Process

#include "Assets/Scripts/Lib/Uriel.cginc"

#define SAMPLE_STEPS 2

RWStructuredBuffer<Particle> _Particles;

int _ParticlesCount;
uint _WaveCount;
float _Size;
StructuredBuffer<Wave> _WaveBuffer;
uint _SolidType;
float _Scale;
float3 _Offset;
float4x4 _Reference;
float _SampleRadius;
float _DeltaTime;
float _Speed;
float _Time;
float _Acceleration;

[numthreads(512, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
 
}

float Distance(float4 a, float4 b)
{
    float4 diff = a - b;
    return sqrt(dot(diff, diff));
}

[numthreads(512, 1, 1)]
void Process(uint3 id : SV_DispatchThreadID)
{
    Particle p = _Particles[id.x];
    const float3 sample_point = p.position * _Scale;
    float3 gradient = float3(0,0,0);
    const Wave wave = _WaveBuffer[0];
    p.charge = 0.0;
    
    const PlatonicSequence sequence = getSequence(wave.type, wave.harmonic);
    const float4 tesseract[16] = {
        float4(-1, -1, -1, -1),
        float4(-1, -1, -1,  1),
        float4(-1, -1,  1, -1),
        float4(-1, -1,  1,  1),
        float4(-1,  1, -1, -1),
        float4(-1,  1, -1,  1),
        float4(-1,  1,  1, -1),
        float4(-1,  1,  1,  1),
        float4( 1, -1, -1, -1),
        float4( 1, -1, -1,  1),
        float4( 1, -1,  1, -1),
        float4( 1, -1,  1,  1),
        float4( 1,  1, -1, -1),
        float4( 1,  1, -1,  1),
        float4( 1,  1,  1, -1),
        float4( 1,  1,  1,  1)
    };
  
    for (int i = 0; i < 16; ++i)
    {
        float4 v = tesseract[i] * wave.density;
        
        for (int x = -SAMPLE_STEPS; x <= SAMPLE_STEPS; x++)
        {
            for (int y = -SAMPLE_STEPS; y <= SAMPLE_STEPS; y++)
            {
                for (int z = -SAMPLE_STEPS; z <= SAMPLE_STEPS; z++)
                {
                    const float3 offset = float3(x, y, z) * wave.depth;
                    const float dist = saturate(Distance(float4(sample_point + offset, 0), v));
                    const float d = sin(dist * wave.frequency) * wave.amplitude;
                    gradient += offset * d;
                    p.charge += d;
                }
            }
        }
    }

    
    p.position -= p.velocity * (_DeltaTime  * max(1, length(sample_point))) * wave.ripples * 0.001;
    p.velocity += gradient * wave.ripples * 0.1 * _DeltaTime;

    _Particles[id.x] = p;
}

