#pragma kernel Init
#pragma kernel Process

#include "Assets/Scripts/Lib/Uriel.cginc"

#define SAMPLE_STEPS 1

RWStructuredBuffer<Particle> _Particles;

int _ParticlesCount;
uint _WaveCount;
float _Size;
StructuredBuffer<Wave> _WaveBuffer;
uint _SolidType;
float _Scale;
float3 _Offset;
float4x4 _Reference;
float _SampleRadius;
float _DeltaTime;
float _Speed;
float _Time;
float _Acceleration;

[numthreads(512, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
 
}

[numthreads(512, 1, 1)]
void Process(uint3 id : SV_DispatchThreadID)
{
    Particle p = _Particles[id.x];
    const float3 sample_point = p.position * _Scale;
    float3 gradient = float3(0,0,0);
    const Wave wave = _WaveBuffer[0];
    p.charge = 0.0;
    
    const PlatonicSequence sequence = getSequence(wave.type, wave.harmonic);
    
    for (int i = 0; i < SEQUENCE_BUFFER_SIZE; ++i)
    {
        const uint seq_index = sequence.indices[i];
        const float3 vertex = PLATONIC_VERTICES[seq_index];
        
        for (int x = -SAMPLE_STEPS; x <= SAMPLE_STEPS; x++)
        {
            for (int y = -SAMPLE_STEPS; y <= SAMPLE_STEPS; y++)
            {
                for (int z = -SAMPLE_STEPS; z <= SAMPLE_STEPS; z++)
                {
                    const float3 offset = float3(x, y, z) * wave.depth;
                    const float dist = saturate(distance(sample_point + offset, vertex) * wave.density * 0.1);
                    const float d = sin(dist * wave.frequency) * wave.amplitude;
                    gradient += offset * d;
                    p.charge += d;
                }
            }
        }
    }
    
    p.position -= p.velocity * (_DeltaTime  * max(1, length(sample_point))) * wave.ripples * 0.001;
    p.velocity += gradient * wave.ripples * 0.1 * _DeltaTime;

    _Particles[id.x] = p;
}

