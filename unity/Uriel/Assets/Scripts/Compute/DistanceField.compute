
#pragma kernel Run

#include "Assets/Scripts/Lib/Uriel.cginc"

#define SHAPE_CUBE 0
#define SHAPE_SPHERE 1
#define SHAPE_CYLINDER 2
#define SHAPE_CAPSULE 3

struct SculptOperation {  
    static const uint ADD = 0;  
    static const uint SUBTRACT = 1;  
    static const uint INTERSECT = 2;  
};

struct SculptSolid {
    float4x4 invTransform;   // inverse transform to local space
    float    scale;          // used for signed distance control
    int      type;           // shape ID: 0 = box, 1 = sphere, 2 = tetra, etc.
    int      op;             // blend op: 0 = add, 1 = subtract, 2 = intersect
    float    feather;        // for smooth blending
};

StructuredBuffer<SculptSolid> _Solids;
int _SolidCount;
RWTexture3D<float> _Field;
uint3 _Dims;
float _Scale;

float2 _Blend;
float4x4 _Transform;

float3 transformPoint(float4x4 m, float3 p)
{
    float4 worldPoint = float4(p, 1.0);
    float4 localPoint = mul(m, worldPoint);
    return localPoint.xyz;
}

// Distance functions for different shapes
float cubeDistance(float3 localPos)
{
    // For a unit cube centered at origin with extents [-0.5, 0.5]
    float3 absPos = abs(localPos);
    float3 outsideDistance = max(absPos - 0.5, 0.0);
    float outsideDist = length(outsideDistance);
    
    // Inside distance (negative when inside)
    float insideDist = max(max(absPos.x, absPos.y), absPos.z) - 0.5;
    
    return max(outsideDist, insideDist);
}

float sphereDistance(float3 localPos)
{
    // For a unit sphere centered at origin with radius 0.5
    return length(localPos) - 0.5;
}

float cylinderDistance(float3 localPos)
{
    // For a unit cylinder along Y axis, radius 0.5, height 1.0 (from -0.5 to 0.5)
    float2 xzPos = localPos.xz;
    float radialDist = length(xzPos) - 0.5;
    float heightDist = abs(localPos.y) - 0.5;
    
    float outsideDist = length(max(float2(radialDist, heightDist), 0.0));
    float insideDist = max(radialDist, heightDist);
    
    return max(outsideDist, insideDist);
}

float capsuleDistance(float3 localPos)
{
    // For a unit capsule along Y axis, radius 0.5, height 1.0
    float yPos = localPos.y;
    yPos = max(abs(yPos) - 0.25, 0.0) * sign(yPos); // Clamp to cylinder part
    
    float2 offset = float2(length(localPos.xz), yPos);
    return length(offset) - 0.5;
}

// Get distance based on shape type
float getShapeDistance(float3 localPos, int shapeType)
{
    switch(shapeType)
    {
    case SHAPE_CUBE:
        return cubeDistance(localPos);
    case SHAPE_SPHERE:
        return sphereDistance(localPos);
    case SHAPE_CYLINDER:
        return cylinderDistance(localPos);
    case SHAPE_CAPSULE:
        return capsuleDistance(localPos);
    default:
        return cubeDistance(localPos);
    }
}

float calculateMask(float distance, float thickness)
{
    if (distance <= 0.0)
        return 1.0;
    if (distance >= thickness)
        return 0.0;
    return smoothstep(1.0, 0.0, distance / thickness);
}

float calculateMaskLinear(float distance, float thickness)
{
    return saturate(1.0 - distance / thickness);
}

float calculateMaskExponential(float distance, float thickness, float falloffPower)
{
    if (distance <= 0.0)
        return 1.0;
    
    float normalizedDist = saturate(distance / thickness);
    return pow(1.0 - normalizedDist, falloffPower);
}

// Combine multiple masks
float combineMasks(float mask1, float mask2, int combineMode)
{
    // Combine modes:
    // 0 = Union (max)
    // 1 = Intersection (min)
    // 2 = Subtract (mask1 - mask2)
    // 3 = Additive (mask1 + mask2, clamped)
    
    switch(combineMode)
    {
    case 0: return max(mask1, mask2);           // Union
    case 1: return min(mask1, mask2);           // Intersection
    case 2: return saturate(mask1 - mask2);     // Subtract
    case 3: return saturate(mask1 + mask2);     // Additive
    default: return max(mask1, mask2);
    }
}

float evaluateSolidField(float3 p, SculptSolid solid)
{
    float4x4 worldToLocal = solid.invTransform;

    float3 localPos = transformPoint(worldToLocal, p);

    float distance = getShapeDistance(localPos, solid.type);

    float shapeMask = calculateMask(distance, solid.feather);
    
    return shapeMask * solid.scale;
}

float sculptField(float3 p)
{
    float result = 0.0;

    for (int i = 0; i < _SolidCount; i++)
    {
        float f = evaluateSolidField(p, _Solids[i]);
        SculptSolid s = _Solids[i];
        if (s.op == 0) { // add
            result = max(result, f);
        }
        else if (s.op == 1) { // subtract
            result = result * (1.0 - f);
        }
        else if (s.op == 2) { // intersect
            result = min(result, f);
        }
    }

    return result;
}



float sampleFieldAt(uint3 pos)
{
    // Convert to centered coordinates
    float ux = float(pos.x - float(_Dims.x) * 0.5) / _Dims.x;
    float uy = float(pos.y - float(_Dims.y) * 0.5) / _Dims.x;
    float uz = float(pos.z - float(_Dims.z) * 0.5) / _Dims.x;
    
    float3 p = float3(ux, uy, uz);
    
    Photon photon = _PhotonBuffer[0];
    float t = 0.0;
    switch (photon.type)
    {
        case 0:
            t = sampleTetrahedral(p, photon, _Transform);
        break;
        case 1:
            t = sampleOctahedron(p, photon, _Transform);
        break;
        case 2:
            t = sampleDragonCurve3D(p, photon, _Transform);
        break;
        default:
            break;
    }
 
    float alpha = lerp(t, _Blend.x, _Blend.y);
    
    alpha *= sculptField(p);

    return alpha;
}

[numthreads(4, 4, 4)]
void Run(uint3 id : SV_DispatchThreadID)
{
    // Early exit if outside texture bounds
    if (any(id >= _Dims))
        return;
        
    _Field[id] = sampleFieldAt(id);
}
