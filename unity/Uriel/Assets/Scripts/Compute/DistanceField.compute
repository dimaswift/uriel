
#pragma kernel Run

#include "Assets/Scripts/Lib/Uriel.cginc"

RWTexture3D<float> _Field;
uint3 _Dims;
float _Scale;

//0 - interference field
//1 - ellipsoid
//2 - rectangle
//3 - donut
// other known distance field shapes
uint _Type;

// Shape parameters
float3 _EllipsoidRadii; // x, y, z radii for ellipsoid
float3 _RectangleSize;  // width, height, depth for rectangle
float2 _DonutParams;    // x = major radius, y = minor radius

// Utility functions
float length2(float3 p) { return dot(p, p); }
float length8(float3 p) { return pow(dot(p, p * p * p), 1.0 / 8.0); }

// Distance function for ellipsoid
float sdEllipsoid(float3 p, float3 r)
{
    float k0 = length(p / r);
    float k1 = length(p / (r * r));
    return k0 * (k0 - 1.0) / k1;
}

// Alternative simpler ellipsoid (less accurate but faster)
float sdEllipsoidSimple(float3 p, float3 r)
{
    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);
}

// Distance function for rounded box/rectangle
float sdRoundedBox(float3 p, float3 b, float r)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

// Distance function for box/rectangle (sharp edges)
float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Distance function for torus/donut
float sdTorus(float3 p, float2 t)
{
    float2 q = float2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// Distance function for vertical torus (donut standing up)
float sdTorusVertical(float3 p, float2 t)
{
    float2 q = float2(length(p.xy) - t.x, p.z);
    return length(q) - t.y;
}

// Distance function for sphere
float sdSphere(float3 p, float r)
{
    return length(p) - r;
}

// Distance function for cylinder
float sdCylinder(float3 p, float h, float r)
{
    float2 d = abs(float2(length(p.xz), p.y)) - float2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Distance function for capsule
float sdCapsule(float3 p, float3 a, float3 b, float r)
{
    float3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

// Distance function for cone
float sdCone(float3 p, float2 c, float h)
{
    float2 q = h * float2(c.x / c.y, -1.0);
    float2 w = float2(length(p.xz), p.y);
    float2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
    float2 b = w - q * float2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
    float k = sign(q.y);
    float d = min(dot(a, a), dot(b, b));
    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
    return sqrt(d) * sign(s);
}

// Boolean operations
float opUnion(float d1, float d2) { return min(d1, d2); }
float opSubtraction(float d1, float d2) { return max(-d1, d2); }
float opIntersection(float d1, float d2) { return max(d1, d2); }

// Smooth boolean operations
float opSmoothUnion(float d1, float d2, float k)
{
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return lerp(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return lerp(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return lerp(d2, d1, h) + k * h * (1.0 - h);
}

// Domain operations
float3 opRepeat(float3 p, float3 c)
{
    return fmod(p + 0.5 * c, c) - 0.5 * c;
}

float3 opTwist(float3 p, float k)
{
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    float2x2 m = float2x2(c, -s, s, c);
    return float3(mul(m, p.xz), p.y);
}

float sampleFieldAt(uint3 pos)
{
    // Convert to centered coordinates
    float ux = float(pos.x - float(_Dims.x) * 0.5);
    float uy = float(pos.y - float(_Dims.y) * 0.5);
    float uz = float(pos.z - float(_Dims.z) * 0.5);
    
    float3 p = float3(ux, uy, uz) * _Scale;
    
    switch (_Type)
    {
        case 0: // Interference field
            return sampleField(p);
            
        case 1: // Ellipsoid
            return sdEllipsoid(p, _EllipsoidRadii);
            
        case 2: // Rectangle/Box
            return sdBox(p, _RectangleSize * 0.5);
            
        case 3: // Donut/Torus
            return sdTorus(p, _DonutParams);
            
        case 4: // Sphere
            return sdSphere(p, _EllipsoidRadii.x); // Use first radius component
            
        case 5: // Rounded Box
            return sdRoundedBox(p, _RectangleSize * 0.5, _DonutParams.y); // Use minor radius for rounding
            
        case 6: // Cylinder
            return sdCylinder(p, _RectangleSize.y * 0.5, _EllipsoidRadii.x);
            
        case 7: // Capsule (vertical)
            return sdCapsule(p, float3(0, -_RectangleSize.y * 0.5, 0), float3(0, _RectangleSize.y * 0.5, 0), _EllipsoidRadii.x);
            
        case 8: // Cone
            return sdCone(p, float2(_EllipsoidRadii.x, _EllipsoidRadii.y), _RectangleSize.y);
            
        case 9: // Vertical Torus
            return sdTorusVertical(p, _DonutParams);
            
        case 10: // Union of sphere and box
            return opUnion(sdSphere(p, _EllipsoidRadii.x), sdBox(p - float3(0, _RectangleSize.y, 0), _RectangleSize * 0.3));
            
        case 11: // Smooth union of sphere and box
            return opSmoothUnion(sdSphere(p, _EllipsoidRadii.x), sdBox(p - float3(0, _RectangleSize.y, 0), _RectangleSize * 0.3), 0.1);
            
        case 12: // Subtraction (sphere with box hole)
            return opSubtraction(sdBox(p, _RectangleSize * 0.3), sdSphere(p, _EllipsoidRadii.x));
            
        case 13: // Repeated spheres
            return sdSphere(opRepeat(p, _RectangleSize), _EllipsoidRadii.x * 0.3);
            
        case 14: // Twisted box
            return sdBox(opTwist(p, 0.1), _RectangleSize * 0.5);
            
        default:
            return 0.0;
    }
}

[numthreads(4, 4, 4)]
void Run(uint3 id : SV_DispatchThreadID)
{
    // Early exit if outside texture bounds
    if (any(id >= _Dims))
        return;
        
    _Field[id] = sampleFieldAt(id);
}
