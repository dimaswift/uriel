#pragma kernel ComputeField
#pragma kernel SimulateParticles
#pragma kernel Clear
#pragma kernel FadeScreen

#include "Assets/Scripts/Lib/Uriel.cginc"

uint _Resolution;
float _Scale;
float _DeltaTime;
float _ScreenFadeSpeed;
float3 _Offset;
int _SpaceResolution;

int _ParticleRadius;
float _Acceleration;
float _Speed;
float _Attraction;
float _Repulsion;
float _Lifetime;
float _PhaseSpeed;

uint _CurrentDimension;

RWTexture3D<float4> _Field;
RWTexture3D<float4> _ParticlePositions;
RWTexture3D<float4> _ParticleVelocities;

RWTexture2D<float4> _Screen;

float3 _Threshold;
float3 _Multiplier;

uint _FieldIndex;


[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    _ParticlePositions[id.xyz] = float4(0,0,0,0);
    _ParticleVelocities[id.xyz] = float4(0,0,0,0);
    _Field[id.xyz] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void FadeScreen(uint3 id : SV_DispatchThreadID)
{
    float4 col = _Screen[id.xy];
    col.a = lerp(col.a, 0, _DeltaTime * _ScreenFadeSpeed);
    _Screen[id.xy] = col;
}

[numthreads(8, 8, 1)]
void ComputeField(uint3 id : SV_DispatchThreadID)
{
    const float xPos = float(id.x) / _Resolution;  
    const float yPos = float(id.y) / _Resolution;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, 0) * _Scale + _Offset;
   
    int res = _SpaceResolution;

    
   // _Field[uint3(id.xy, _CurrentDimension)] = density > 0 ? float4(density, 0, 0, _Threshold.z) : float4(0, 0, abs(density), _Threshold.z);
}

[numthreads(8, 1, 1)]
void SimulateParticles(uint3 id : SV_DispatchThreadID)
{
    float4 particlePos = _ParticlePositions[uint3(id.xy, _CurrentDimension)];
    float4 particleVel = _ParticleVelocities[uint3(id.xy, _CurrentDimension)];
    if (particlePos.z <= 0)
    {
        return;
    }
    const uint2 pixelPos = uint2(clamp(particlePos.x, 0, _Resolution), clamp(particlePos.y, 0, _Resolution));
    float2 gradient = float2(0, 0);
    int checks = 0;
    float accumulatedCharge = 0.0;
    const int rad = _ParticleRadius;
    for (int x = -rad; x <= rad; ++x)
    {
        for (int y = -rad; y <= rad; ++y)
        {
            int2 checkPoint = int2(particlePos.x + x, particlePos.y + y);
            checkPoint.x = clamp(checkPoint.x, 0, _Resolution);
            checkPoint.y = clamp(checkPoint.y, 0, _Resolution);
            float4 interference = _Field[uint3(checkPoint, _CurrentDimension)];
            gradient -= float2(x, y) * interference.r * _Attraction;
            gradient += float2(x, y) * interference.b * _Repulsion;
            checks++;
            accumulatedCharge += interference.r;
            accumulatedCharge -= interference.b;
        }
    }

    particleVel.xy -= (gradient / checks) * _DeltaTime * _Acceleration;
    particlePos.xy += _DeltaTime *  particleVel.xy * _Speed;

    if (particlePos.x < 0 || particlePos.x >= float(_Resolution))
    {
        particlePos.z = 0;
    } 

    if (particlePos.y < 0 || particlePos.y >= float(_Resolution))
    {
        particlePos.z = 0;
    }
    
    particlePos.w += _DeltaTime * _PhaseSpeed * accumulatedCharge;
    particlePos.z -= _DeltaTime / _Lifetime;
    
    float4 screenColor = _Screen[pixelPos];
    float3 rgb = lerp(float3(1.0, 0, 0), float3(0, 0, 1.0), particlePos.w);
    screenColor.rgb = rgb;
    screenColor.a = 1;
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = particlePos;
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = particleVel;
    _Screen[pixelPos] = screenColor;
}