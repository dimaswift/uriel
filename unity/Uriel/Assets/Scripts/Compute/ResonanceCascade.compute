#pragma kernel ComputeField
#pragma kernel ClearField
#pragma kernel ClearScreen
#pragma kernel RenderScreen
#pragma kernel RenderParticles
#pragma kernel ComputeParticles
#pragma kernel SpawnParticles
#pragma kernel FadeParticles
#pragma kernel CollapseField
#pragma kernel ClearParticles

#include "Assets/Scripts/Lib/Uriel.cginc"

struct Resonance
{
    int current;
};

uint _FieldResolution;
uint _ParticleResolution;
float _Scale;
float _DeltaTime;
float _CanvasFadeSpeed;
float3 _Offset;

int _ParticleRadius;
float _Acceleration;
float _Speed;
float _Attraction;
float _Repulsion;
float _Lifetime;
float _PhaseSpeed;
float _Time;
float _Gravity;
float _Radius;

uint2 _MousePosition;
uint _CurrentDimension;
uint _Dimensions;
RWTexture3D<float4> _ParticlePositions;
RWTexture3D<float4> _ParticleVelocities;

RWStructuredBuffer<Resonance> _ResonanceBuffer;
RWTexture3D<float4> _Field;
RWTexture2D<float4> _Screen;
RWTexture2D<float4> _ParticleCanvas;
Texture2D<float4> _Gradient;
float _GradientSize;

float _GradientThreshold;
float _GradientMultiplier;

uint _CurrentScreen;
uint _SpawnCounter;
float2 _SpawnPoint;

StructuredBuffer<Modulation> _ModulationBuffer;
uint _ModulationCount;

[numthreads(8, 8, 1)]
void ClearField(uint3 id : SV_DispatchThreadID)
{
    _Field[id.xyz] = float4(0,0,0,0);

}

[numthreads(8, 8, 1)]
void ClearParticles(uint3 id : SV_DispatchThreadID)
{
    _ParticlePositions[id.xyz] = float4(0,0,0,0);
    _ParticleVelocities[id.xyz] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void ClearScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = float4(0,0,0,0);
    _ParticleCanvas[id.xy] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void FadeParticles(uint3 id : SV_DispatchThreadID)
{
    const float2 center = float2(id.x - float(_ParticleResolution) / 2, id.y - float(_ParticleResolution) / 2);
    float4 col = _ParticleCanvas[id.xy];
    col.a = lerp(col.a, 0, _DeltaTime * _CanvasFadeSpeed);
    _ParticleCanvas[id.xy] = col;
}

[numthreads(8, 8, 1)]
void RenderScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = _Field[uint3(id.xy, _CurrentScreen)];
}

[numthreads(8, 8, 1)]
void RenderParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentScreen)];
    const uint2 pixelPos = uint2(round(pos.x), round(pos.y));
    if (pixelPos.x < 0 || pixelPos.x >= _ParticleResolution || pixelPos.y < 0 || pixelPos.y >= _ParticleResolution)
    {
        return;
    }
    
    float4 prevPos = _ParticleVelocities[uint3(id.xy, _CurrentScreen)];
  
    float4 col = _ParticleCanvas[pixelPos];
    float m = length(prevPos.xy - pos) * _GradientMultiplier * 0.001;
    col.w += _DeltaTime * _Lifetime;
    col.xyz = hsv2rgb(length(prevPos.xy - pos) * _GradientThreshold * 0.001, 1, m);
    _ParticleCanvas[pixelPos] = col;
}

[numthreads(8, 8, 1)]
void CollapseField(uint3 id : SV_DispatchThreadID)
{

    float4 p = _ParticlePositions[uint3(id.xy, _CurrentDimension)] ;
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = float4(id.x, id.y, p.z, 1.0);
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = float4(id.x, id.y, 0, 1);
}

[numthreads(8, 8, 1)]
void ComputeField(uint3 id : SV_DispatchThreadID)
{
    const float xPos = float(id.x) / (_FieldResolution - 1);  
    const float yPos = float(id.y) / (_FieldResolution - 1);
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    const float density = sampleField(uv, _ModulationBuffer[0]);
    float3 col =  density > 0 ? float3(density, 0, 0) : float3(0, 0, abs(density));
    _Field[uint3(id.xy, _CurrentDimension)] = float4(density,density,density, 1);
    if(_CurrentDimension == 1)
    {
        _Field[uint3(id.xy, _CurrentDimension)] = float4(0,0,0, 1);
    }
}

float sampleF(uint2 id)
{
    const float xPos = float(id.x) / (_FieldResolution - 1);  
    const float yPos = float(id.y) / (_FieldResolution - 1);
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    return  sampleField(uv, _ModulationBuffer[0]);
}

[numthreads(8, 8, 1)]
void ComputeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentDimension)];

    //it's dormant (alpha is almost zero, a ghost per se), no need to process it further
    // if (pos.w <= 0.001)
    // {
    //     return;
    // }
    const float halfRes = (_FieldResolution - 1) / 2;
    const float2 center = float2(pos.x - halfRes, pos.y - halfRes);
    float4 prevPos = _ParticleVelocities[uint3(id.xy, _CurrentDimension)];
    const int2 fieldCoords = int2(round(pos.x), round(pos.y));
    const int rad = _ParticleRadius;
    float2 fieldConvergence = float2(0, 0);
    const float4 centerDensity = _Field[uint3(fieldCoords, _CurrentDimension)];

    
    for (int x = -rad; x <= rad; x++)
    {
        for (int y = -rad; y <= rad; y++)
        {
            int2 checkPoint = int3(fieldCoords.x + x, fieldCoords.y + y, _CurrentDimension);
            if(checkPoint.x < 0 || checkPoint.x >= _FieldResolution
                || checkPoint.y < 0 || checkPoint.y >= _FieldResolution)
            {
                continue;
            }
            const float4 fieldDensity = _Field[uint3(checkPoint, _CurrentDimension)];
            fieldConvergence += float2(x, y) * fieldDensity.r * _Attraction;
        }
    }
    float2 acceleration = float2(fieldConvergence.x, fieldConvergence.y) * _Acceleration;

    float2 tmp = pos.xy;
    pos.xy = 2.0 * tmp - prevPos.xy + acceleration * _Speed * _Speed;
    prevPos.xy = tmp;
   
    //particle is out of bounds, but information is not lost
    //it's re-emitted from the eyes preserving phase and velocity
    if (length(center) > _FieldResolution * _Radius)
    {
      //  pos.z += _PhaseSpeed;
        float eyeWidth = 0.1;
        float eyeHeight = 1.5;
        float eyeHorizontal = halfRes + _ParticleResolution * eyeWidth * sign(center.x);
        float eyeVertical = float(_ParticleResolution - 1) / eyeHeight;
        float2 vel = pos - prevPos;
        prevPos.xy = pos + normalize(acceleration) * _Gravity;
        
        pos.xy = float2(eyeHorizontal,eyeVertical);
        if(center.y > 0)
        {
            pos.xy = float2(eyeHorizontal, -eyeVertical);
        }
        else
        {
            //third eye is guided by hand (first biofeedback?)
            pos.xy = _MousePosition;
         //   pos.xy = float2(eyeHorizontal, -eyeVertical);
        }
        prevPos.xy = pos - normalize(vel + acceleration) * _Gravity;
        //
        // //reverse velocity upon entering the abyss, but preserve direction
        // vel *= -1;
        // //limit velocity for stability purposes
        // if (length(vel) > _FieldResolution * _Gravity)
        // {
        //     vel = normalize(vel) * _FieldResolution * _Gravity;
        // }
       

    }
    else
    {
        //cycle phase A.K.A lifecycle
       
    }

 
    
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = pos;
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = prevPos;
}

[numthreads(1, 1, 1)]
void SpawnParticles(uint3 id : SV_DispatchThreadID)
{
    uint c = _SpawnCounter;
    while (c > 0)
    {
        uint x = round(_SpawnPoint.x);
        uint y = round(_SpawnPoint.y);
        _ParticlePositions[uint3(x, y, _CurrentScreen)] = float4(x,y,0,1);
        _ParticleVelocities[uint3(x, y, _CurrentScreen)] = float4(x,y,0,0);
        c--;
    }
}
