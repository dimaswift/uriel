#pragma kernel ComputeField
#pragma kernel ClearField
#pragma kernel ClearScreen
#pragma kernel RenderScreen
#pragma kernel RenderParticles
#pragma kernel ComputeParticles
#pragma kernel SpawnParticles
#pragma kernel FadeParticles
#pragma kernel CollapseField

#include "Assets/Scripts/Lib/Uriel.cginc"

struct Resonance
{
    int current;
};

uint _Resolution;
float _Scale;
float _DeltaTime;
float _CanvasFadeSpeed;
float3 _Offset;

int _ParticleRadius;
float _Acceleration;
float _Speed;
float _Attraction;
float _Repulsion;
float _Lifetime;
float _PhaseSpeed;
float _Time;
float _Gravity;
float _Radius;

uint _CurrentDimension;
uint _Dimensions;
RWTexture3D<float4> _ParticlePositions;
RWTexture3D<float4> _ParticleVelocities;

RWStructuredBuffer<Resonance> _ResonanceBuffer;
RWTexture3D<float4> _Field;
RWTexture2D<float4> _Screen;
RWTexture2D<float4> _ParticleCanvas;
Texture2D<float4> _Gradient;
float _GradientSize;

float _GradientThreshold;
float _GradientMultiplier;

uint _CurrentScreen;
uint _SpawnCounter;
float2 _SpawnPoint;

StructuredBuffer<Modulation> _ModulationBuffer;
uint _ModulationCount;

[numthreads(8, 8, 1)]
void ClearField(uint3 id : SV_DispatchThreadID)
{
    _Field[id.xyz] = float4(0,0,0,0);
    _ParticlePositions[id.xyz] = float4(0,0,0,0);
    _ParticleVelocities[id.xyz] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void ClearScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = float4(0,0,0,0);
    _ParticleCanvas[id.xy] = float4(1,1,1,0);
}

[numthreads(8, 8, 1)]
void FadeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 col = _ParticleCanvas[id.xy];
    col.a = lerp(col.a, 0, _DeltaTime * _CanvasFadeSpeed);
    _ParticleCanvas[id.xy] = col;
}

[numthreads(8, 8, 1)]
void RenderScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = _Field[uint3(id.xy, _CurrentScreen)];
}

[numthreads(8, 8, 1)]
void RenderParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentScreen)];
    float4 vel = _ParticleVelocities[uint3(id.xy, _CurrentScreen)];
    const uint2 pixelPos = uint2(clamp(pos.x, 0, _Resolution), clamp(pos.y, 0, _Resolution));
    float4 col = _ParticleCanvas[pixelPos];
    col.w += _DeltaTime * _Lifetime;
    float m = length(vel.xy) * _GradientMultiplier * 0.001;
   // col.xyz = _Gradient[uint2(uint(pos.z * _GradientThreshold * 0.001) % uint(_GradientSize), 0)] * m;
    col.xyz = hsv2rgb(pos.z * _GradientThreshold * 0.001 * m, 1, 1);
    _ParticleCanvas[pixelPos] = col;
}

[numthreads(8, 8, 1)]
void CollapseField(uint3 id : SV_DispatchThreadID)
{
    if(distance(float2(float(_Resolution) / 2, float(_Resolution) / 2), id.xy) < float(_Resolution) / 2)
    {
        _ParticlePositions[uint3(id.xy, _CurrentDimension)] = float4(id.xy, 0, 1);
    }
}

[numthreads(8, 8, 1)]
void ComputeField(uint3 id : SV_DispatchThreadID)
{
    const float xPos = float(id.x) / _Resolution;  
    const float yPos = float(id.y) / _Resolution;
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    const float density = sampleField(uv, _ModulationBuffer[0]);
    float3 col =  density > 0 ? float3(density, 0, 0) : float3(0, 0, abs(density));
    _Field[uint3(id.xy, _CurrentDimension)] = float4(col, 1);
}

[numthreads(8, 8, 1)]
void ComputeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentDimension)];
    
    if (pos.w <= 0.001)
    {
        return;
    }
    
    const float2 center = float2(pos.x - float(_Resolution) / 2, pos.y - float(_Resolution) / 2);
    float4 vel = _ParticleVelocities[uint3(id.xy, _CurrentDimension)];
    
    const int rad = _ParticleRadius;
    float2 fieldConvergence = float2(0,0);
    float density = 0;
    for (int x = -rad; x <= rad; x++)
    {
        for (int y = -rad; y <= rad; y++)
        {
            int3 checkPoint = int3(pos.x + x, pos.y + y, _CurrentDimension);
            checkPoint.x = clamp(checkPoint.x, 0, _Resolution);
            checkPoint.y = clamp(checkPoint.y, 0, _Resolution);
            float4 global = _Field[uint3(checkPoint)];
            fieldConvergence += float2(x, y) * global.r * _Attraction;
            fieldConvergence -= float2(x, y) * global.b * _Attraction;
            pos.z += global.r * _DeltaTime * _PhaseSpeed;
            pos.z -= global.b * _DeltaTime * _PhaseSpeed;
        }
    }

    const float2 force = fieldConvergence * _Acceleration * _DeltaTime / sqrt(length(center));
    
    vel.xy += force;
    pos.xy += vel.xy * _Speed * _DeltaTime;
    
    if(pos.z >= _GradientSize)
    {
       // pos.z = 0;
    }

    if (length(center) > _Resolution * _Radius)
    {
        pos.xy = int2(float(_Resolution) / 2, float(_Resolution) / 2);
        vel *= -_Gravity;
      //  pos.z += _DeltaTime * _PhaseSpeed;
    }
    
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = pos;
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = vel;
}

[numthreads(1, 1, 1)]
void SpawnParticles(uint3 id : SV_DispatchThreadID)
{
    uint c = _SpawnCounter;
    while (c > 0)
    {
        uint x = round(_SpawnPoint.x);
        uint y = round(_SpawnPoint.y);
        _ParticlePositions[uint3(x, y, _CurrentScreen)] = float4(x,y,0,1);
        _ParticleVelocities[uint3(x, y, _CurrentScreen)] = float4(0,0,0,0);
        c--;
    }
}
