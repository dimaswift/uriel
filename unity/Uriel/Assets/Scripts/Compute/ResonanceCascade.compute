#pragma kernel ComputeField
#pragma kernel ClearField
#pragma kernel ClearScreen
#pragma kernel RenderScreen
#pragma kernel RenderParticles
#pragma kernel ComputeParticles
#pragma kernel SpawnParticles
#pragma kernel FadeParticles
#pragma kernel CollapseField

#include "Assets/Scripts/Lib/Uriel.cginc"

struct Resonance
{
    int current;
};

uint _Resolution;
float _Scale;
float _DeltaTime;
float _CanvasFadeSpeed;
float3 _Offset;

int _ParticleRadius;
float _Acceleration;
float _Speed;
float _Attraction;
float _Repulsion;
float _Lifetime;
float _PhaseSpeed;
float _Time;
float _Gravity;

uint _CurrentDimension;
uint _Dimensions;
RWTexture3D<float4> _ParticlePositions;
RWTexture3D<float4> _ParticleVelocities;

RWStructuredBuffer<Resonance> _ResonanceBuffer;
RWTexture3D<float4> _Field;
RWTexture2D<float4> _Screen;
RWTexture2D<float4> _ParticleCanvas;

float3 _Threshold;
float3 _Multiplier;

uint _CurrentScreen;
uint _SpawnCounter;
float2 _SpawnPoint;

StructuredBuffer<Modulation> _ModulationBuffer;
uint _ModulationCount;

[numthreads(8, 8, 1)]
void ClearField(uint3 id : SV_DispatchThreadID)
{
    _Field[id.xyz] = float4(0,0,0,0);
    _ParticlePositions[id.xyz] = float4(0,0,0,0);
    _ParticleVelocities[id.xyz] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void ClearScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = float4(0,0,0,0);
    _ParticleCanvas[id.xy] = float4(1,1,1,0);
}

[numthreads(8, 8, 1)]
void FadeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 col = _ParticleCanvas[id.xy];
    col.a = lerp(col.a, 0, _DeltaTime * _CanvasFadeSpeed);
    _ParticleCanvas[id.xy] = col;
}

[numthreads(8, 8, 1)]
void RenderScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = _Field[uint3(id.xy, _CurrentScreen)];
    
}

[numthreads(8, 8, 1)]
void RenderParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentScreen)];
    const uint2 pixelPos = uint2(clamp(pos.x, 0, _Resolution), clamp(pos.y, 0, _Resolution));
    float4 col = _ParticleCanvas[pixelPos];
    col.w += _DeltaTime * _Lifetime;
    col.xyz = float3(1,1,1);
    _ParticleCanvas[pixelPos] = col;
}

[numthreads(8, 8, 1)]
void CollapseField(uint3 id : SV_DispatchThreadID)
{
    float4 density = _Field[uint3(id.xy, _CurrentDimension)];
    if(length(id.xy) < float(_Resolution) / 2)
    {
      
    }
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = float4(id.xy, 0, 1);
}

[numthreads(8, 8, 1)]
void ComputeField(uint3 id : SV_DispatchThreadID)
{
    const float xPos = float(id.x) / _Resolution;  
    const float yPos = float(id.y) / _Resolution;
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    const float density = sampleField(uv, _ModulationBuffer[0]);
    float3 col =  density > 0 ? float3(density, 0, 0) : float3(0, 0, abs(density));
    _Field[uint3(id.xy, _CurrentDimension)] = float4(col, _Threshold.z);
}

[numthreads(8, 8, 1)]
void ComputeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentDimension)];
    
    if (pos.w <= 0.001)
    {
        return;
    }
    float2 center = float2(pos.x - float(_Resolution) / 2, pos.y - float(_Resolution) / 2);
    float4 vel = _ParticleVelocities[uint3(id.xy, _CurrentDimension)];
    
    const int rad = _ParticleRadius;
    float2 fieldConvergence = float2(0,0);
    float2 repulsion = float2(0,0);
    float2 attraction = float2(0,0);
    
    float accumulatedCharge = 0;
    
    for (int x = -rad; x <= rad; x++)
    {
        for (int y = -rad; y <= rad; y++)
        {
            int3 checkPoint = int3(pos.x + x, pos.y + y, _CurrentDimension);
            checkPoint.x = clamp(checkPoint.x, 0, _Resolution);
            checkPoint.y = clamp(checkPoint.y, 0, _Resolution);
            float4 global = _Field[uint3(checkPoint)];
            float4 local = _ParticleCanvas[checkPoint.xy];
            fieldConvergence += float2(x, y) * global.r * _Attraction;
            fieldConvergence -= float2(x, y) * global.b * _Attraction;

           // repulsion -= float2(x, y) * local.r * -pos.z * _Repulsion;
           // attraction -= float2(x, y) * local.b * pos.z * _Attraction;
            
           // accumulatedCharge -= global.r * _DeltaTime * _Gravity;
           // accumulatedCharge += global.b * _DeltaTime * _Gravity;
        }
    }

     float2 v =(fieldConvergence + repulsion + attraction) * _Acceleration * _DeltaTime / sqrt(length(center));
    
     vel.zw += v;
         
     pos.xy += vel.zw * _Speed * _DeltaTime;
    
    //pos.xy += v;
    pos.z = 1;
    if(abs(pos.z) > _Threshold.x)
    {
      //  pos.z = 0;
        //pos.xy = int2(float(_Resolution) / 2, float(_Resolution) / 2);
      // vel = float4(0,0,0,0);
    }

    if (length(center) > _Resolution)
    {
        pos.xy = int2(float(_Resolution) / 2, float(_Resolution) / 2);
        vel *= _Gravity;
    }
    
    // if (pos.x < 0 || pos.x >= float(_Resolution))
    // {
    //   //  pos.z = 0;
    //     pos.xy = int2(float(_Resolution) / 2, float(_Resolution) / 2);
    //    // vel = float4(0,0,0,0);
    // } 
    //
    // if (pos.y < 0 || pos.y >= float(_Resolution))
    // {
    //  //   pos.z = 0;
    //     pos.xy = int2(float(_Resolution) / 2, float(_Resolution) / 2);
    //   //  vel = float4(0,0,0,0);
    // }

    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = pos;
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = vel;
}

[numthreads(1, 1, 1)]
void SpawnParticles(uint3 id : SV_DispatchThreadID)
{
    uint c = _SpawnCounter;
    while (c > 0)
    {
        uint x = round(_SpawnPoint.x);
        uint y = round(_SpawnPoint.y);
        _ParticlePositions[uint3(x, y, _CurrentScreen)] = float4(x,y,0,1);
        _ParticleVelocities[uint3(x, y, _CurrentScreen)] = float4(0,0,0,0);
        c--;
    }
}
