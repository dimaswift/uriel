#pragma kernel ComputeField
#pragma kernel ClearField
#pragma kernel ClearScreen
#pragma kernel RenderScreen
#pragma kernel RenderParticles
#pragma kernel ComputeParticles
#pragma kernel SpawnParticles
#pragma kernel FadeParticles
#pragma kernel CollapseField
#pragma kernel ClearParticles

#include "Assets/Scripts/Lib/Uriel.cginc"

struct Resonance
{
    int current;
};

uint _FieldResolution;
uint _ParticleResolution;
float _Scale;
float _DeltaTime;
float _CanvasFadeSpeed;
float3 _Offset;

int _ParticleRadius;
float _Acceleration;
float _Speed;
float _Attraction;
float _Repulsion;
float _Lifetime;
float _PhaseSpeed;
float _Time;
float _Gravity;
float _Radius;

uint2 _MousePosition;
uint _CurrentDimension;
uint _Dimensions;
RWTexture3D<float4> _ParticlePositions;
RWTexture3D<float4> _ParticleVelocities;

RWStructuredBuffer<Resonance> _ResonanceBuffer;
RWTexture3D<float4> _Field;
RWTexture2D<float4> _Screen;
RWTexture2D<float4> _ParticleCanvas;
Texture2D<float4> _Gradient;
float _GradientSize;

float _GradientThreshold;
float _GradientMultiplier;

uint _CurrentScreen;
uint _SpawnCounter;
float2 _SpawnPoint;

StructuredBuffer<Modulation> _ModulationBuffer;
uint _ModulationCount;

[numthreads(8, 8, 1)]
void ClearField(uint3 id : SV_DispatchThreadID)
{
    _Field[id.xyz] = float4(0,0,0,0);

}

[numthreads(8, 8, 1)]
void ClearParticles(uint3 id : SV_DispatchThreadID)
{
    _ParticlePositions[id.xyz] = float4(0,0,0,0);
    _ParticleVelocities[id.xyz] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void ClearScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = float4(0,0,0,0);
    _ParticleCanvas[id.xy] = float4(0,0,0,0);
}

[numthreads(8, 8, 1)]
void FadeParticles(uint3 id : SV_DispatchThreadID)
{
    const float2 center = float2(id.x - float(_ParticleResolution) / 2, id.y - float(_ParticleResolution) / 2);
    float4 col = _ParticleCanvas[id.xy];
    col.a = lerp(col.a, 0, _DeltaTime * _CanvasFadeSpeed);
    _ParticleCanvas[id.xy] = col;
}

[numthreads(8, 8, 1)]
void RenderScreen(uint3 id : SV_DispatchThreadID)
{
    _Screen[id.xy] = _Field[uint3(id.xy, _CurrentScreen)];
}

[numthreads(8, 8, 1)]
void RenderParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentScreen)];
    const uint2 pixelPos = uint2(round(pos.x), round(pos.y));
    if (pos.w == 0 || pixelPos.x < 0 || pixelPos.x >= _ParticleResolution || pixelPos.y < 0 || pixelPos.y >= _ParticleResolution)
    {
        return;
    }
    
    float4 vel = _ParticleVelocities[uint3(id.xy, _CurrentScreen)];
    float4 col = _ParticleCanvas[pixelPos];
    float m = length(vel.xy) * _GradientMultiplier * 0.001;
    col.w += _DeltaTime * _Lifetime;
    col.xyz = hsv2rgb(pos.z * _GradientThreshold * 0.001 * m, 1, 1);
    _ParticleCanvas[pixelPos] = col;
}

[numthreads(8, 8, 1)]
void CollapseField(uint3 id : SV_DispatchThreadID)
{
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = float4(id.x, id.y, 0, 1);
}

[numthreads(8, 8, 1)]
void ComputeField(uint3 id : SV_DispatchThreadID)
{
    const float xPos = float(id.x) / (_FieldResolution - 1);  
    const float yPos = float(id.y) / (_FieldResolution - 1);
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    const float density = sampleField(uv, _ModulationBuffer[0]);
    float3 col =  density > 0 ? float3(density, 0, 0) : float3(0, 0, abs(density));
    _Field[uint3(id.xy, _CurrentDimension)] = float4(density,density,density, 1);
    if(_CurrentDimension == 1)
    {
        _Field[uint3(id.xy, _CurrentDimension)] = float4(0,0,0, 1);
    }
}

float sampleF(uint2 id)
{
    const float xPos = float(id.x) / (_FieldResolution - 1);  
    const float yPos = float(id.y) / (_FieldResolution - 1);
    const float zPos = float(_CurrentDimension) / _Dimensions;
    const float3 uv = float3(xPos - 0.5, yPos - 0.5, zPos - 0.5) * _Scale;
    return  sampleField(uv, _ModulationBuffer[0]);
}

[numthreads(8, 8, 1)]
void ComputeParticles(uint3 id : SV_DispatchThreadID)
{
    float4 pos = _ParticlePositions[uint3(id.xy, _CurrentDimension)];
    
    if (pos.w <= 0.001)
    {
        return;
    }
    const float ratio = (_FieldResolution - _ParticleResolution);
    const float2 center = float2(pos.x - float(_ParticleResolution - 1) / 2, pos.y - float(_ParticleResolution - 1) / 2);
    float4 vel = _ParticleVelocities[uint3(id.xy, _CurrentDimension)];
    int2 fieldPos = int2(round(pos.x + ratio * 0.5),round(pos.y + ratio * 0.5));
    const int rad = _ParticleRadius;
    float2 fieldConvergence = float2(0,0);
    float4 density = _Field[uint3(fieldPos, _CurrentDimension)];
    
    for (int x = -rad; x <= rad; x++)
    {
        for (int y = -rad; y <= rad; y++)
        {
            int2 checkPoint = int3(fieldPos.x + x, fieldPos.y + y, _CurrentDimension);
            if(checkPoint.x < 0 || checkPoint.x >= _FieldResolution
                || checkPoint.y < 0 || checkPoint.y >= _FieldResolution)
            {
                continue;
            }
            float4 global = _Field[uint3(checkPoint, _CurrentDimension)];
            fieldConvergence += float2(x, y) * global.r * _Attraction;
           // fieldConvergence -= float2(x, y) * global.b * _Attraction;
        }
    }
    
    // pos.z += _PhaseSpeed * _DeltaTime * sampleF(fieldPos);;
    // int2 checkPoint = int3(fieldPos.x + 1, fieldPos.y, _CurrentDimension);
    // float global = sampleF(checkPoint);
    // fieldConvergence += float2(1, 0) * global * _Attraction;
    //
    // checkPoint = int3(fieldPos.x - 1, fieldPos.y, _CurrentDimension);
    // global = sampleF(checkPoint);
    // fieldConvergence += float2(-1, 0) * global * _Attraction;
    //
    // checkPoint = int3(fieldPos.x, fieldPos.y + 1, _CurrentDimension);
    // global = sampleF(checkPoint);;
    // fieldConvergence += float2(0, 1) * global * _Attraction;
    //
    // checkPoint = int3(fieldPos.x, fieldPos.y - 1, _CurrentDimension);
    // global = sampleF(checkPoint);
    // fieldConvergence += float2(0, -1) * global * _Attraction;
 
   
  //  pos.z -= _PhaseSpeed * _DeltaTime * density.b;
    
    const float2 force = fieldConvergence * _Acceleration;
    
    vel.xy += force * _DeltaTime;
    pos.xy += vel.xy * _Speed * _DeltaTime;
    
    if(pos.z >= _GradientSize)
    {
       // pos.z = 0;
    }

    if (length(center) > _FieldResolution * _Radius)
    {
       pos.xy = _MousePosition;
       // pos.xy = float2(float(_ParticleResolution - 1) / 2, float(_ParticleResolution - 1) / 2) + force;
       //pos.xy = int2(float(_Resolution) / 4, float(_Resolution) / 4);
        vel *=  -_Gravity;
        pos.z += _DeltaTime * _PhaseSpeed;
    }
    
    _ParticlePositions[uint3(id.xy, _CurrentDimension)] = pos;
    _ParticleVelocities[uint3(id.xy, _CurrentDimension)] = vel;
}

[numthreads(1, 1, 1)]
void SpawnParticles(uint3 id : SV_DispatchThreadID)
{
    uint c = _SpawnCounter;
    while (c > 0)
    {
        uint x = round(_SpawnPoint.x);
        uint y = round(_SpawnPoint.y);
        _ParticlePositions[uint3(x, y, _CurrentScreen)] = float4(x,y,0,1);
        _ParticleVelocities[uint3(x, y, _CurrentScreen)] = float4(0,0,0,0);
        c--;
    }
}
